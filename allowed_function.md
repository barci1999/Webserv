# Archivo de funciones permitidas

 - ## gestion de procesos:
	**- fork:** funcion la cual crea un nuevo proceso duplicando el actual, este nuevo proceso comparte inicialmente codigo y datos por eso es iportante tener en cuenta herencia de memoria dinamica alocada y fds abiertos.
	- prototipo: `pid_t fork(void);`
	- valores de retorno: 
		- ` > 0` proceso padre;
		- ` = 0 ` proceso hijo;
		- ` = -1 ` error no se pudo creear el proceso;

	**- execve:** ejecuta un programa atraves que se encuentra en el pathname,si cuando se ejecuta execve se realiza correctamente cuando termina la ejecucion del programa designado se termina el proceso automanticamente,mientras que si falla la ejecucion se deber terminar el proceso de forma manual
	- prototipo: `int execve(const char *pathname, char *const argv[],char *const envp[]);`
	- parametros:
		- `const char *pathname`: ruta de archivos del programa a ejecutar.
		- ` char **const argv`: matriz de argumentos para el programa a ejecutar.
		- ` char **const envp`: matriz de string que trabajara conmo environment del programa.
	
	**- waitpid:** funcion que se utiliza en el proceso padre para esperar al resultado del proceso hijo ya sea exitosa la ejecucion de lo que haga o no.
	- protptipo: `pid_t waitpid(pid_t pid, int *wstatus, int options);`
	- parametros:
		- `pid_t pid`: id del proceso al que va a esperar:
			- `> 0`: espera al proceso con ese pid en concreto.
			- `= -1`:espera a cualquier proceso hijo.
			- `= 0`: espera a cualquier proceso hijo del mismo grupo.
			- `< -1`:espera a cualquier hijo del grupo `|pid|`.
		- `int *wstatus`:puntero de int donde el kernel guarda como termino el proceso.
			- `WIFEXITED(status)`:el hijo termino normalmente.
			- `WEXITSTATUS(status)`:el hijo termino atraves de un `exit(x)`.
			- `WIFSIGNALED(status)`:el proceso se termino con una señal.
			- `WTERMSIG(status)`: que señar mato al proceso.
		- `int options`:indica el tipo de espera:
			- `0`:espera de forma bloqueante.
			- `WNOHANG`:no bloquea,devuelve:
				- `0`:si el hijo esta vivio.
				- `PID`:si termino l proceso.
	- valores de retorno:
		- `> 0`:el PID del proceso hijo a cambiado por lo cual a terminado ya sea de forma correcta o incorrecta.
		- `= 0`:solo ocurre si se usa `WNOHAN` indica que el hijo sigue ejecutandose.
		- `= -1`:Error se produce cuando no hay hijos,el pid es invalido o cuando se produce un error en el sistema.

	**- kill**: funcion utilizada para mandar una señal a un proceso (no necesariamente se mata al proceso depende de la señal qie se mande).
	- prototipo: `int kill(pid_t pid, int sig);`
	- parametros:
		- `pid_t pid`:proceso al que se le envia la señal.
			- `pid > 0`: se envia la señal a ese proceso en concreto.
			- `pid == 0`:se envia la señal a todos los procesos del grupo que el proceso llamador.
			- `pid == -1`:se envia la señal a todos los procesos a los que el proceso tenga ermiso.
			- `pid < -1`:se encia la señar al grupo de procesos `-pid`.
		- `int sing`:señal que se envia.
			-`SIGTERM`:terminacion limpia.
			-`SIGKILL`:matar inmediatamente al proceso.
			-`SIGINT`:interrupcion como por ejemplo `Ctrl+c`.
			-`SIGQUIT`:termina el proceso y genera un `core dump`.
			-`0`:no envia señal simplemente comprueba si el proceso existe y tiene permiso.
	- valores de retorno:
		- `0`:todo bien y funciono correctamente.
		- `-1`:algo no funciono correctamente y se modifico el valor de `enrro`:
			-`ESRCH`: el proceso no existe.
			-`EPERM`: no tienes permisos para enviar la señal.
			-`EINVAL`: señal invalida.
	
	**- signal**:permite definir como un proceso maneja una señal se puede(capturar la señal,ignorarla,restaurar su comportamiento por defecto).Se usa para gestionar eventos asincronos como interrupciones o la terminacion de procesos hijos.
	- prototipo: `void (*signal(int sig, void (*handler)(int)))(int);`.
	- parametros:
		- `sig`: la señal que se quiere manejar.
			-`SIGINT`:interrupcion (ctrl + c).
			-`SIGTERM`:terminacion ordenada.
			-`SIGQUIT`:salida con core dump.
			-`SIGCHLD`:un proceso hijo termino.
		- `handler`:funcion que se ejecutara cuando el proceso reciba la señal.
			-`SIG_DFL`:comportamiento por defecto.
			-`SIG_IGN`:ignorar señal.
			-`handler`: fucion definida por el usuario.
	- valor de retorno:
		- `handler anterior`:en caso de ejcucion exitosa devuelve el handler anterior.
		- `SIG_ERR`:retornado cuando se produce un error y se modifica enrro.
			- `EINVAL`:señal invalida.
	
	**- pipe**:crea un canal de comunicacion unidireccional entre procesos,permite que un proceso escriba datos y otro los lea usando descriptores de archivos.
	- prototipo:`int pipe(int fd[2]);`.
	- parametros:
		- `fd[0]`:extremo de lectura.
		- `fd[1]`:extremo de escritura.
	- valores de retorno:
		- `0`: ejecucion exitosa.
		- `-1`: Error(modifica enrro).
			- `modificacion de errno`
				- `EMFILE`: el proceso tiene demasiados fds abiertos.
				- `ENFILE`:el sistema alcanzo el limite de fds.
				- `EFAULT`:fd apunta a una direccion invalida.
 
 - ## gestion de sockets
	- **creacion y comunicacion**
		- **socket**:crea un endpoint de comunicacion y devuelve un descriptor de archivo que representa a un socket.
			- prototipo:`int socket(int domain, int type, int protocol)`;
			- parametros:
				- `domain`:especifica la familia de direcciones.
					- `AF_INET`:IPv4.
					- `AF_INET6`:IPv6.
					- `AF_UNIX`:sockets locales.
				- `type`:define el tipo de comunicacion.
					- `SOCK_STREAM`:comunicacion orientada a conexion(TCP).(HTTP usa SOCK_STREAM).
					- `SOCK_DGRAM`:Datagramas(UDP).
				- `protocol`:protocolo especifico dentro del dominio.
					- `0`:el sistema elige el protocolo por defecto.
					- `IPPROTO_TCP`:para TCP.
			- valores de retorno:
				- `>= 0`:exito.
				- `-1`:Error modifica errno.
					- `EACCES`:Permiso denegado.
					- `EMFILE`: demasiados fds abiertos.
					- `ENFILE`: limite del sistema alcanzado.
					- `EINVAL`: parametros invalidos.
					- `ENOBUFS`: memoria insuficiente.
		- **socketpair**:crea dos sockets conectaddos entre si ,permite la comunicacion bidireccional entre dos procesos(o dentro del mismo proceso) sin usar una red.
			- prototipo: `int socketpair(int domain, int type, int protocol, int sv[2])`;
			- parametros:
				- `domain`: familia de direcciones.
					- `AF_UNIX`: sockets locales (socket pair solo funciona con `AF_UNIX`.).
				- `type`: tipo de socket.
					- `SOCK_STREAM`: flujo bidireccional.
					- `SOCK_DGRAM`: datagramas.
				- `protocol`:protocolo especifico (siempre `0`).
				- `sv`:array de dos esnteros que rtecibe los sockets (ambos sockets pueden leer y escribir).
					- `sv[0]`: primer socket.
					- `sv[1]`: segundo socket.
			- valor de retorno:
				- `0`:exito.
				- `-1`:Error (se modifica errno)
					- `EAFNOSUPPORT`:dominio no soportado.
					- `EMFILE`:demasiados fd abiertos.
					- `ENFILE`:limite del sistema.
					- `EINVAL`:parametros invalidos.
		- **bind**:asocia un socket a una direccion(IP + puerto).En un servidor,indica en que puerto y direccion ca a escuchar.
			- prototipo: `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen`;
			- parametros:
				- `sockfd`: descriptor del archivo del socket creado previamente con `socket()`.
				- `addr`: estructura la cual indica la direccion a la que se asocia el socket.
					- `struct de addr`
						- `sa_family_t    sin_family`: indica a familia de direcciones (siempre `AF_INET` para IPv4) debe coincidir con el `domain` usado en el socket.
						- `in_port_t      sin_port;` puerto en el que el servidor va a escuchar.el puerto debe ir en el network byte order por eso se usa `htons()`.
						- `struct in_addr sin_addr;`estructura que contiene un `uint32_t`en el que se guarda la direccion IP.
				- `addrlen`:tamaño de la estructura `addr`.
			- valores de retorno:
				- `0`: Exito.
				- `-1`: Error (se modifica errno).
					- `EADDRINUSE`: el puerto ya esta en uso.
					- `EACCES`: permiso denegado (puertos < 1024).
					- `EINVAL`:Socket ya esta enlazado.
					- `EBADF`:sockfd invalido.
					- `EADDRNOTAVAIL`:ip no valida en el sistema.
		- **listen**:marca un socket como pasico(lo prepara para aceptar conexiones entrantes).convierte un socket TCP ya bineado en un socket de escucha.
			- protipo: `int listen(int sockfd, int backlog)`;
			- parametros:
				- `sockfd`: descriptor del socket previamente creado con `socket()`y asociado con `bind()`.
				- `backlog`: numero maximo de conexiones pendientes en la cola de espera.
					- Define cuántos clientes pueden estar esperando a que el servidor haga `accept()`.
					- El sistema puede limitar o ajustar este valor.
			- valores de retorno:
				- `0`:exito.
				- `-1`:error (se modifica errno).
					- `EBADF`: `sockfd` invalido.
					- `EINVAL`: el socket no esta bindeado.
					- `EOPNOTSUPP`: el socket no soporta `listen()`.
					- `ENOTSOCK`: `sockfd`no es un socket.
				
		- **accept**
		- **connect**
		- **send**
		- **recv**
	- **configuracion y utilidades de red**
		- **setsockopt**
		- **getsockname**
		- **getprotobyname**
		- **htons**
		- **htonl**
		- **ntohs**
		- **ntohl**
	- **resolucion de direcciones**
		- **getaddrinfo**
		- **freeaddrinfo**
		- **gai_strerror**
 - ## Multiplexación de I/O
	- **select**
	- **poll**
	- **epoll**
		- **epoll_create**
		- **epoll_ctl**
		- **epoll_wait**
	- **kqueue**
	- **kevent**
 - ## Gestión de ficheros y sistema
	- **open**
	- **close**
	- **read**
	- **write**
	- **stat**
	- **access**
	- **opendir** 
	- **readdir**
	- **closedir**
	- **fcntl**
	- **dup**
	- **dup2**
	- **chdir**
 - ## Utilidades y errores
	- **errno**
	- **strerror**

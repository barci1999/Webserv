# Archivo de funciones permitidas

 - ## gestion de procesos:
	**- fork:** funcion la cual crea un nuevo proceso duplicando el actual, este nuevo proceso comparte inicialmente codigo y datos por eso es iportante tener en cuenta herencia de memoria dinamica alocada y fds abiertos.
	- prototipo: `pid_t fork(void);`
	- valores de retorno: 
		- ` > 0` proceso padre;
		- ` = 0 ` proceso hijo;
		- ` = -1 ` error no se pudo creear el proceso;

	**- execve:** ejecuta un programa atraves que se encuentra en el pathname,si cuando se ejecuta execve se realiza correctamente cuando termina la ejecucion del programa designado se termina el proceso automanticamente,mientras que si falla la ejecucion se deber terminar el proceso de forma manual
	- prototipo: `int execve(const char *pathname, char *const argv[],char *const envp[]);`
	- parametros:
		- `const char *pathname`: ruta de archivos del programa a ejecutar.
		- ` char **const argv`: matriz de argumentos para el programa a ejecutar.
		- ` char **const envp`: matriz de string que trabajara conmo environment del programa.
	
	**- waitpid:** funcion que se utiliza en el proceso padre para esperar al resultado del proceso hijo ya sea exitosa la ejecucion de lo que haga o no.
	- protptipo: `pid_t waitpid(pid_t pid, int *wstatus, int options);`
	- parametros:
		- `pid_t pid`: id del proceso al que va a esperar:
			- `> 0`: espera al proceso con ese pid en concreto.
			- `= -1`:espera a cualquier proceso hijo.
			- `= 0`: espera a cualquier proceso hijo del mismo grupo.
			- `< -1`:espera a cualquier hijo del grupo `|pid|`.
		- `int *wstatus`:puntero de int donde el kernel guarda como termino el proceso.
			- `WIFEXITED(status)`:el hijo termino normalmente.
			- `WEXITSTATUS(status)`:el hijo termino atraves de un `exit(x)`.
			- `WIFSIGNALED(status)`:el proceso se termino con una señal.
			- `WTERMSIG(status)`: que señar mato al proceso.
		- `int options`:indica el tipo de espera:
			- `0`:espera de forma bloqueante.
			- `WNOHANG`:no bloquea,devuelve:
				- `0`:si el hijo esta vivio.
				- `PID`:si termino l proceso.
	- valores de retorno:
		- `> 0`:el PID del proceso hijo a cambiado por lo cual a terminado ya sea de forma correcta o incorrecta.
		- `= 0`:solo ocurre si se usa `WNOHAN` indica que el hijo sigue ejecutandose.
		- `= -1`:Error se produce cuando no hay hijos,el pid es invalido o cuando se produce un error en el sistema.

	**- kill**: funcion utilizada para mandar una señal a un proceso (no necesariamente se mata al proceso depende de la señal qie se mande).
	- prototipo: `int kill(pid_t pid, int sig);`
	- parametros:
		- `pid_t pid`:proceso al que se le envia la señal.
			- `pid > 0`: se envia la señal a ese proceso en concreto.
			- `pid == 0`:se envia la señal a todos los procesos del grupo que el proceso llamador.
			- `pid == -1`:se envia la señal a todos los procesos a los que el proceso tenga ermiso.
			- `pid < -1`:se encia la señar al grupo de procesos `-pid`.
		- `int sing`:señal que se envia.
			-`SIGTERM`:terminacion limpia.
			-`SIGKILL`:matar inmediatamente al proceso.
			-`SIGINT`:interrupcion como por ejemplo `Ctrl+c`.
			-`SIGQUIT`:termina el proceso y genera un `core dump`.
			-`0`:no envia señal simplemente comprueba si el proceso existe y tiene permiso.
	- valores de retorno:
		- `0`:todo bien y funciono correctamente.
		- `-1`:algo no funciono correctamente y se modifico el valor de `enrro`:
			-`ESRCH`: el proceso no existe.
			-`EPERM`: no tienes permisos para enviar la señal.
			-`EINVAL`: señal invalida.
	
	**- signal**:permite definir como un proceso maneja una señal se puede(capturar la señal,ignorarla,restaurar su comportamiento por defecto).Se usa para gestionar eventos asincronos como interrupciones o la terminacion de procesos hijos.
	- prototipo: `void (*signal(int sig, void (*handler)(int)))(int);`.
	- parametros:
		- `sig`: la señal que se quiere manejar.
			-`SIGINT`:interrupcion (ctrl + c).
			-`SIGTERM`:terminacion ordenada.
			-`SIGQUIT`:salida con core dump.
			-`SIGCHLD`:un proceso hijo termino.
		- `handler`:funcion que se ejecutara cuando el proceso reciba la señal.
			-`SIG_DFL`:comportamiento por defecto.
			-`SIG_IGN`:ignorar señal.
			-`handler`: fucion definida por el usuario.
	- valor de retorno:
		- `handler anterior`:en caso de ejcucion exitosa devuelve el handler anterior.
		- `SIG_ERR`:retornado cuando se produce un error y se modifica enrro.
			- `EINVAL`:señal invalida.
	
	**- pipe**:crea un canal de comunicacion unidireccional entre procesos,permite que un proceso escriba datos y otro los lea usando descriptores de archivos.
	- prototipo:`int pipe(int fd[2]);`.
	- parametros:
		- `fd[0]`:extremo de lectura.
		- `fd[1]`:extremo de escritura.
	- valores de retorno:
		- `0`: ejecucion exitosa.
		- `-1`: Error(modifica enrro).
			- `modificacion de errno`
				- `EMFILE`: el proceso tiene demasiados fds abiertos.
				- `ENFILE`:el sistema alcanzo el limite de fds.
				- `EFAULT`:fd apunta a una direccion invalida.
 
 - ## gestion de sockets
	- **creacion y comunicacion**
		- **socket**:crea un endpoint de comunicacion y devuelve un descriptor de archivo que representa a un socket.
			- prototipo:`int socket(int domain, int type, int protocol)`;
			- parametros:
				- `domain`:especifica la familia de direcciones.
					- `AF_INET`:IPv4.
					- `AF_INET6`:IPv6.
					- `AF_UNIX`:sockets locales.
				- `type`:define el tipo de comunicacion.
					- `SOCK_STREAM`:comunicacion orientada a conexion(TCP).(HTTP usa SOCK_STREAM).
					- `SOCK_DGRAM`:Datagramas(UDP).
				- `protocol`:protocolo especifico dentro del dominio.
					- `0`:el sistema elige el protocolo por defecto.
					- `IPPROTO_TCP`:para TCP.
			- valores de retorno:
				- `>= 0`:exito.
				- `-1`:Error modifica errno.
					- `EACCES`:Permiso denegado.
					- `EMFILE`: demasiados fds abiertos.
					- `ENFILE`: limite del sistema alcanzado.
					- `EINVAL`: parametros invalidos.
					- `ENOBUFS`: memoria insuficiente.
		- **socketpair**:crea dos sockets conectaddos entre si ,permite la comunicacion bidireccional entre dos procesos(o dentro del mismo proceso) sin usar una red.
			- prototipo: `int socketpair(int domain, int type, int protocol, int sv[2])`;
			- parametros:
				- `domain`: familia de direcciones.
					- `AF_UNIX`: sockets locales (socket pair solo funciona con `AF_UNIX`.).
				- `type`: tipo de socket.
					- `SOCK_STREAM`: flujo bidireccional.
					- `SOCK_DGRAM`: datagramas.
				- `protocol`:protocolo especifico (siempre `0`).
				- `sv`:array de dos esnteros que rtecibe los sockets (ambos sockets pueden leer y escribir).
					- `sv[0]`: primer socket.
					- `sv[1]`: segundo socket.
			- valor de retorno:
				- `0`:exito.
				- `-1`:Error (se modifica errno)
					- `EAFNOSUPPORT`:dominio no soportado.
					- `EMFILE`:demasiados fd abiertos.
					- `ENFILE`:limite del sistema.
					- `EINVAL`:parametros invalidos.
		- **bind**:asocia un socket a una direccion(IP + puerto).En un servidor,indica en que puerto y direccion ca a escuchar.
			- prototipo: `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen`;
			- parametros:
				- `sockfd`: descriptor del archivo del socket creado previamente con `socket()`.
				- `addr`: estructura la cual indica la direccion a la que se asocia el socket.
					- `struct de addr`
						- `sa_family_t    sin_family`: indica a familia de direcciones (siempre `AF_INET` para IPv4) debe coincidir con el `domain` usado en el socket.
						- `in_port_t      sin_port;` puerto en el que el servidor va a escuchar.el puerto debe ir en el network byte order por eso se usa `htons()`.
						- `struct in_addr sin_addr;`estructura que contiene un `uint32_t`en el que se guarda la direccion IP.
				- `addrlen`:tamaño de la estructura `addr`.
			- valores de retorno:
				- `0`: Exito.
				- `-1`: Error (se modifica errno).
					- `EADDRINUSE`: el puerto ya esta en uso.
					- `EACCES`: permiso denegado (puertos < 1024).
					- `EINVAL`:Socket ya esta enlazado.
					- `EBADF`:sockfd invalido.
					- `EADDRNOTAVAIL`:ip no valida en el sistema.
		- **listen**:marca un socket como pasico(lo prepara para aceptar conexiones entrantes).convierte un socket TCP ya bineado en un socket de escucha.
			- protipo: `int listen(int sockfd, int backlog)`;
			- parametros:
				- `sockfd`: descriptor del socket previamente creado con `socket()`y asociado con `bind()`.
				- `backlog`: numero maximo de conexiones pendientes en la cola de espera.
					- Define cuántos clientes pueden estar esperando a que el servidor haga `accept()`.
					- El sistema puede limitar o ajustar este valor.
			- valores de retorno:
				- `0`:exito.
				- `-1`:error (se modifica errno).
					- `EBADF`: `sockfd` invalido.
					- `EINVAL`: el socket no esta bindeado.
					- `EOPNOTSUPP`: el socket no soporta `listen()`.
					- `ENOTSOCK`: `sockfd`no es un socket.
				
		- **accept**: acepta un  conexion entrante en una socket de escucha,crea un nuevo socket dedicado exclusivamente a ese cliente(este socket no se usa para comunicar datos solo para aceptar conexiones).
			- prototipo: `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`;
			- parametros:
				- `socketfd`: socket en modo escucha previamente configurado con: `socket()`,`bind()`,`listen()`.
				- `addr`: estructura donde se almacena la direccion del cliente (puede ser `NULL`si no interesa la informacion).(se suele usar `struct sockaddr_in`).
				- `addrlen`: tamaño de ña estructura `addr`,se pasa como puntero ,el kernel lo actualiza con el tamaño real.
			- valores de retorno:
				- `client_fd`: nuevo socket de escucha del cliente.
				- `-1`: Error (se modifica errno).
					- `EAGAIN` / `EWOULDBLOCK`: no hay conexiones pendientes (socket no bloqueante).
					- `EBADF`: sockfd invalido.
					- `EINVAL`: el socket no esta en modo escucha.
					- `EMFILE`: demasiados fds abiertos.
					- `ENOTSOCK`: no es un socket.

		- **connect**: inicia una conexion desde un socket hacia una direccion remota. en TCP: establece la conexion con un servidor,debe llamarse antes de `send()`/`recv`.
			- prototipo: `int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)`;
			- parametros:
				- `sockfd`: descriptor del socket creado por `socket()`.
				- `addr`: estructura que es la direccion del servidor remoto (IP + puerto).
				- `addrlen`: tamaño de la estructura apuntada por `addr`.
			- valores de retorno:
				- `0`:conexion establecida.
				- `-1`:Error (se modifica errno).
					- `ECONNREFUSED`: el servidor rechazo a conexion.
					- `ETIMEDOUT`: tiempo de espera agotado.
					- `EINPROGRESS`: conecsion en curso(socket no bloqueante).
					- `EADDRNOTAVAIL`: direccion invalida.
					- `ENETUNREACH`: red no alcanzable.
		- **send**: envia datos a traves de un sicket conectado. se usa para enviar informacion al cliente o al servidor, normalmente despues de `accept()`o `connect()`.
			- prototipo: `ssize_t send(int sockfd, const void *buf, size_t len, int flags)`;
			- parametros:
				- `sockfd`: socket conectado -> devuelto por `accept()` o usado con `connect()`.
				- `buf`: buffer que contiene los datos a enviar.
				- `len`: numero de bytes a enviar desde `buff`.
				- `flags`: opciones de envio.
					- `0`:envio normal.
					- `MSG_NOSIGNAL`: evita el `SIGPIPE`si el socket esta cerrado.
			- valores de retorno:
				- `n`: bytes enviados.
				- `-1`: Error (se modificar errno).
					- `EPIPE`: socket cerrado por el otro lado.
					- `ECONNRESET`: conexion reiniciada.
					- `EAGAIN`/ `EWOULDBLOCK`:socket no bloqueante,no se puede enviar ahora.
					- `EBADF`:`sockfd` invalido.
				
		- **recv**: redibe datos desde un socket conectado y los copia en un buffer. se usa para leer peticiones HTTP u otros datos enviados por el cliente o servidor.
			- prototipo: `ssize_t recv(int sockfd, void *buf, size_t len, int flags);`
			- parametros:
				- `sockfd`: socket conectado -> devuelto por `accept()` o usado con `connect()`.
				- `buf`: buffer donde se almacenaran los daros recibidos.
				- `len`: numero maximo de bytes a recibir.
				- `flags`: opciones de recepcion.
					- `0`: recepcion normal.
					- `MSG_DONTWAIT`: no bloquea.
					- `MSG_PEEK`: lee sin consumir datos.
			- valores de retorno:
				- `n`: bytes recibidos. 
				- `0`: conexion cerrada ordenadamente.
				- `-1`: Error (se modifica errno).
					- `EAGAIN`/`EWOULDBLOCK`: no hay datos disponibles (no bloqueante).
					- `ECONNRESET`: conexion reiniciada.
					- `EBADF`: `sockfd`invalido.
					- `ENOTCONN`: socket no conectado.
	- **configuracion y utilidades de red**
		- **setsockopt**: configura opciones de una socket y modifica su comportamiento se usa para: reutilizar puertos ,configurar timeouts, Activar/desactivar opciones del socket.
			- prototipo: `int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)`.
			- parametros:
				- `sockfd`: descriptor del socket creado por `socket()`.
				- `level`: Nivel al que pertenece la opcion:
					- `SOL_SOCKET`: opciones generales del socket.
					- `IPPROTO_TCP`: opciones especificas del TCP.
				- `optname`: opcion que se quiere modificar:
					- `SO_REUSEADDR`: reutilizar direccion /puerto (nivel -> `SOL_SOCKET`).
					- `SO_REUSEPORT`: reutilizar puerto si esta disponible (nivel -> `SOL_SOCKET`).
					- `SO_RCVTIMEO`: timeout de recepcion (nivel -> `SOL_SOCKET`).
					- `SO_SNDTIMEO`: timeout de envio (nivel -> `SOL_SOCKET`).
				- `optval`: puntero al calor de la opcion.
				- `optlen`: tamaño de optval.
			- valores de retorno:
				- `0`: exito.
				- `-1`: Error (se modifica errno).
					- `EBADF`: sockfd invalido.
					- `ENOPROTOOPT`: opcion no soportada.
					- `EINVAL`: Parametros ivalidos.
					- `EFAULT`: optval invalido.

		- **getsockname**: obtiene la direccion llocal asociada a un socket: permite sbaer su ip local y su puerto asignado real.
			- prototipo: `int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`;
			- parametros:
				- `sockfd`: descriptor del socket del cual se quiere obtener la informacion.
				- `addr`: estructura donde se almacenara la direccion local de socket.
				- `addrlen`: tamaño de addr.
			- valores de retorno:
				- `0`: Exito.
				- `-1`: Error (se modifica errno).
					- `EBADF`: sockfd invalido. 
					- `ENOTSOCK`: no es un socket.
					- `EFAULT`: `addr`o `addrlen` invalidos.
					- `EINVAL`: socket no tiene una direccion asociada.
		- **getprotobyname**: obtiene informacion sobre un protocolo de red a partir de su nombre,se usa para convertir un nombre como `"tcp"` o `"udp"` en su numero de protocolo.
			- prototipo: `struct protoent *getprotobyname(const char *name)`;
			- parametros:
				- `name`: nombre del protocolo. (comunes `"tcp"` o `"udp"`).
			- valores de retorno:
				- `NULL`: Error.
				- `struct proent *`:exito.
					- esta structura tiene:
						- `char *p_name`: nombre oficial del protocolo.
						- `char **p_aliases`: Alias.
						- `int p_proto`: numero de protocolo.
		- **htons**: convierte un entero de 16 bits de `host byte order`a `network byte order`,se usa principalmente para convertir puertos antes de enviarlos por red.
			- prototipo: `uint16_t htons(uint16_t hostshort)`;
			- parametros:
				- `hostshort`: Numero de 16 bist en orden de bytes del host.
			- valores de retorno:
				- `networkshort`: valor en nerwork byte order (importante esta funcion no falla).
		
		- **htonl**; convierte un entero de 32 bits de `host byte order` a `network byte order`, se usa priincipalmente para direcciones IPv4 y otros valores de 32 bits enviados por red.
			- prototipo: `uint32_t htonl(uint32_t hostlong)`;
			- parametros:
				- `hostlong`: entero de 32 bites en order de bytes de host.
			- valores de retorno:
				- `networklong`: valoer en network byte order (importante esta funcion no falla).

		- **ntohs**: convierte un entero de 16 bits de `networl byte order` a `host byte order`,se usa principalmente para leer numeros de puerto recibidos desde la red.
			- prototipo : `uint16_t ntohs(uint16_t netshort)`;
				- `netshort` : Numero de 16 bits en network byte order.
			- valores de retorno:
				- `hostshort` : valor en host byte order (importante esta funcion no falla).

		- **ntohl**: convierte un entero de 32 bits de `network byte order` a `host byte order`,se usa principalmente para leer numeros de puerto recibidos desde la red.
			- prototipo : `uint32_t ntohl(uint32_t netlong);`;
				- `netlong` : Numero de 32 bits en network byte order.
			- valores de retorno:
				- `hostlong` : valor en host byte order (importante esta funcion no falla).

	- **resolucion de direcciones**
		- **getaddrinfo**: resuelve direcciones de red. convierte un host(`localhost`,`127.0.0.1`,`NULL`) y un servicio (`8080`) en una lista de estructuras `addrinfo`listas para unsar con `socket()`,`bind()`,`conect()`,etc.
			- prototipo: `int getaddrinfo(const char *node,const char *service,const struct addrinfo *hints,struct addrinfo **res)`;
			- parametros:
				- `node` : nombre del host o direccion.
				- `service`: servicion o puerto como string.
				- `hints`: estructura que indica qie tipo de dicecciones quieres (tipo de struct addrinfo).
				- `res`: puntero a una lista enlazada de `struct addrinfo`.
			- valores de retorno:
				- `= 0`: exito.
				- `!= 0`: Error. (no modifica errno)
					- los errores se interpretan `gai_strerror()`.
		- **freeaddrinfo**: libera la memoria reservada con `getaddrinfo()`(`getaddrinfo()` crea una lista elazada dinamica de estructuras addrinfo).
			- prototipo: `void freeaddrinfo(struct addrinfo *res)`;
			- parametros: 
				- `res`: puntero a la lista de `struct addrinfo`devuelta por detaddrinfo().
			- valores de retorno :
				- no devuelve nada.
		- **gai_strerror**: convierte los codigos de error de `getaddrinfo()`en mensajes legibles (no usa errno)
			- prototipo: `const char *gai_strerror(int errcode)`;
			- parametros:
				- `errcode` : condigo devuelto por `getaddrinfo()` o `getnameinfo()`.
			- valor de retorno
				- `mensaje`: mensaje de error devuelto.
	 - ## Multiplexación de I/O
		- **select**: permite vugilar multiples doscriptoes de archivo(sockets,pipes,ficheros) y esperar hasta que alguno este listo para:leer,escribir o tenga una exepcion .Evita bloquear el servidor en un solo cliente.
			- prototipo: `int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)`;
			- parametros:
				- `nfds`: numeros del descriptor mas alto `+1`que quieres vigilar.
				- `readfds`: conjunto de descriptores a vigilar para lectura.
					- un fd estara listo si:
						- `recv()` no lo bloquearia.
						- hay una conexion pendiaente (`accept()`).
				- `writefds`:conjunto de descriptores listos para escritura.
					- un fd estara listo si:
						- `send()`: no bloquearia.
				- `exceptfd`: conjunto para condiciones execpcionales.
				- `timeout`: tiempo maximo de espera
					- valores:
						- `NULL`: espera indefinida.
						- `{0,0}`: no espera (polling).
						- `valores positivos`: espera limitada.
			- valores de retorno:
				- ` > 0`: numero de fds listos.
				- ` == 0`:timeout.
				- ` == -1`: Error (modifica errno). 
					- `EBADF`: fd invalido.
					- `EINTR`: señal recibida.
					- `EINVAL`: argumentos erroneos.
					- `ENOMEM`: falta de memoria.

		- **poll**: monitoriza multiples descriptores de archivo y espera hasta que alguno este listo para realizar operaciones de E/S.a diferencia de `select()`no tiene limite fijo de fds no usa bitmasks ,no necesita recalcular `nfds`.
			- prototipo: `int poll(struct pollfd *fds, nfds_t nfds, int timeout)`;
			- parametros:
				- `fds`: Array de estructuras `struct pollfd` que describe que fds vigilar y que eventos interesan.
				- `nfds`: numero de elementos en el array `fds` (no es el fd maximo , es el tamaño del array).
				- `timeout`: tiempo de espera maximo en milisegundos
					- `-1`: espera indefinida.
					- `0`: no bloquea.
					- `> 0`: espera limitada.
			- valores de retorno:
				- `> 0`: numero de fds con enventos.
				- `== 0`: timeout.
				- `== -1`: Error (se modifica errno).
					- `EBADF`: fd invalido.
					- `EINTR`: señal recibida.
					- `EINVAL`: argumentos invalidos.
					- `ENOMEM`: falta memoria.
		- **epoll**: (NO ES UNA FUNCION COMO TAL ES UN CONJUNTO DE LLAMADAS A OTRAS  FUNCIONES.)es un mecanismo de multiplexacion eficiente y escalable ,diseñado para manejar muchisimos descriptores . A diferencia de `select` y `poll`no recorre los fds, funciona por eventos,es O(1) por evento.
			- **epoll_create**: crea una instancia de epoll y devuelve un descriptor:
				- prototipo: `int epoll_create(int size)`;
				- parametros:
					`size`: actualmente no sirve de mucho en esta funcion simplemente a funcion comprueba que sea mayor que 0.(en el pasa era el numero maximo estimado e descriptores que ibas a monitorizar).
				- valores de retorno:
					- `>= 0`: epoll fd.
					- `== -1`: Error (se modifica errno).
						- `EINVAL` : argumentos invalidos.
						- `EMFILE`/ `ENFILE`: limite de fds.
						- `ENOMEM`: si memoria.

			- **epoll_ctl**:Añade ,modifica o elimina la instancia de `epoll`.
				- prototipo: `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`;
				- parametros:
					- `epfd`: descriptor e la instancia de epoll devuelta por `epoll_create()`.
					- `op`: operaciones a realizar:
						- `EPOLL_CTL_ADD`: añadir fd a eppoll.
						- `EPOLL_CTL_MOD`: modificar eventos.
						- `EPOLL_CTL_DEL`: eliminar fd.
					- `fd`: descriptor que quieres controlar (socket del servidor,socket del cliente,pipe,etc.).
					- `event`:describle que eventos te interesan y que dato asociar al fd:
						- dentro de la estructura envents encontramos:
							- `uint32_t events`: eventos que quieres monitorizar:
								- `EPOLLIN`: listo para leer.
								- `EPOLLOUT`: listo para escribir.
								- `EPOLLERR`: error.
								- `EPOLLHUP`: cierre.
								- `EPOLLET`: edge-triggered (avanzado).
							- `epoll_data_t data`: informacion asociada al fd.
				- valores de retorno:
					- `== 0`: exito.
					- `== -1`: Error (se modificar errno)
						- `EBADF`: `epfd`o `fd` invalido.
						- `EEXIST`: `fd` ya añadido. 
						- `ENOENT`: `fd` no existe (MOD/DEL).
						- `EINVAL`: argumentos invalidos.
						- `ENOMEM`: sin memoria.
			- **epoll_wait**:bloquea el proceso hasta que uno o mas descriptores registrados en la instancia `epoll` reciban eventos.
				- prototipo: `int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout)`;
				- parametros:
					- `epfd`: descriptor e la instancia de epoll devuelta por `epoll_create()`.
					- `events`: Array donde el kernek escribe los enventos listos.
					- `maxevents`: Numero maximo de eventos que puede contener el array de `events` (debe ser mayor que `0`).
					- `timeout`: tiempo maximo en milisegundos.
						- `-1`: esoera indefinida.
						- `0`: no bloquea.
						- `> 0`: esoera limitada.
				- valores de retorno:
					- ` > 0`: numero de eventos devueltos.
					- `== 0`: time out.
					- ` == -1`: Error (se modifica errno).
						- `EBADF`: epdf invalido.
						- `EINTR`: interrumpido por señal.
						- `EINVAL`: argumentos invalidos.
	- ## Gestión de ficheros y sistema
		- **open**: esta funcion se utiliza para abrir un archivo y obtener un file descriptor(fd) que luego se usará para leer o escribir en él.
			- prototipo: `int open(const char *pathname, int flags, mode_t mode);`
			- parametros:
				- `const char *pathname`: ruta de archivo a abrir.
				- `flags`: cómo se abre el archivo.
					- `O_RDONLY`: solo lectura.
					- `O_WRONLY`: solo escritura.
					- `O_RDWR`: lectura y escritura.
					- `O_CREAT`: crea el archivo si no existe.
					- `O_TRUNC`: trunca el archivo.
				- `mode_t mode`: permisos del archivo(solo si se usa `O_CREAT`).
			- valores de retorno:
				- `>= 0`: file descriptor válido.
				- `= -1`: error al abrir o crear el archivo.

		- **close**: esta función cierra un file descriptor, se utiliza para cerrarlos y asi no provocar fugas de recursos.
			- prototipo: `int close(int fd);`
			- pparametros:
				- `fd`: file descriptor a cerrar.
			- valores de retorno:
				- `0`: cerrado correctamente.
				- `1`:error al cerrar.

		- **read**: esta funcion lee datos desde un file descriptor (archivo, socket, pipe, etc.) y los guarda en un buffer. En este proyecto si se usa `read`en sockets se debe usar antes `poll()`.
			- prototipo: ` ssize_t read(int fd, void *buf, size_t count);`
			- parametros:
				- `fd`: file descriptor desde el que se lee.
				- `buf`: buffer donde se guardan los datos.
				- `count`: número maximo de bytes a leer.
			- valores de retorno:
				-`> 0`: número de bytes leídos.
				-`= 0`: fin de archivos(EOF).
				-`= -1`: error de lectura.

		- **write**: esta funcion escribe datos desde un buffer a un file descriptor.
			- prototipo: `ssize_t write(int fd, const void *buf, size_t count);`
			- parametros:
				- `fd`: file descriptor donde se escribe.
				- `buf`: buffer con los datos.
				- `count`: numero de bytes a escribir.
			- valores de retorno:
				- `> 0`: bytes escritos.
				- `= 0`: no se escribio nada.
				- `= -1`: error,

		- **stat**: esta funcion btiene información sobre un archivo o directorio (tipo, tamaño, permisos, etc.), se puede usar para saber si una ruta es un archivo, o si el directorio existe.
			- prototipo: `int stat(const char *pathname, struct stat *buf);`
			- parametros:
				- `pathname`: ruta del archivo.
				- `buf`: estructura donde se guarda la informacion
			- valores de retorno:
				- `0`: permitido.
				- `-1`: no permitido.

		- **access**: esta funcion comprueba permisos sobre un archivo sin abrirlo.
			- prototipo: `int access(const char *pathname, int mode);`
			- parametros:
				- `pathname`: ruta del archivo.
				- `mode`: permiso a comprobar:
					- `F_OK`: existe.
					- `R_OK`: lectura.
					- `W_OK`: escritura.
					- `X_OK`: ejecucion.
			- valores de retorno:
				-`0`: permitido.
				-`-1`: no permitido o no existente.

		- **opendir** : esta funcion abre un directorio para poder leer su contenido.
			- prototipo: `DIR *opendir(const char *name);`
			- parametros:
				- `name`: ruta del directorio.
			- valores de retorno:
				- puntero `DIR*`: éxito.
				- `NULL`: error.

		- **readdir** : esta funion lee una entrada (archivo o subdirectorio) dentro de un directorio abierto.
			- prototipo: `struct dirent *readdir(DIR *dirp);`
			- parametros:
				- `dirp`: directorio abierto con `opendir`.
			- valores de retorno:
				- puntero a `struct direct`: entrada leída.
				- `NULL`: no hay mas archivos o error.

		- **closedir**: esta funcion cierra un directorio abierto con `opendir`
			- prototipo: `int closedir(DIR *dirp);`
			- parametros:
				- `dirp`: directorio a cerrar.
			- valores de retorno:
				- `0`: cerrado correctamente.
				- `-1`: error.

		- **fcntl**: esta funcion permite modificar o consultar propiedades de un file descriptor.
			- prototipo: `int fcntl(int fd, int cmd, ...);`
			- parametros:
				- `fd`: file descriptor sobre el que se quiere actuar.
				- `cmd`: comando que indica la operacion a realizar.
				- `...`: argumentos adicionales dependientes del comando.
			- comandos permitidos en webserv (macOS):
				- `F_SETFL`: establece flags de estado del fd.
					- `O_NONBLOCK`: pone el fd en modo no bloqueante.
				- `FD_CLOEXEC`: cierra automaticamente el fd al ejecutar `execve`.
			- valores de retorno:
				- `>= 0`: operacion realizada con exito.
				- `-1`: error.

		- **dup**: esta funcion duplica un file descriptor existente, creando una nueva referencia al mismo recurso (archivo, socket, pipe, etc).
			- prototipo: `int dup(int oldfd);`
			- parametros:
				- `oldfd`: file descriptor que se desea duplicar.
			- valores de retorno:
				- `>= 0`: nuevo file descriptor que apunta al mismo recurso que `oldfd`.
				- `-1`: error, file descriptor invalido o error del sistema.
			- detalles:
				- el nuevo fd comparte el mismo offset de lectura/escritura.
				- cerrar uno no cierra el otro.

		- **dup2**: esta funcion duplica un file descriptor en uno especifico, cerrando previamente el file descriptor destino si estaba abierto, en este proyecto se usa en CGI para redirigir la entrada y salida estandar.
			- prototipo: `int dup2(int oldfd, int newfd);`
			- parametros:
				- `oldfd`: file descriptor original que se quiere duplicar.
				- `newfd`: file descriptor destino (por ejemplo `STDIN_FILENO` o `STDOUT_FILENO`).
			- valores de retorno:
				- `>= 0`: devuelve `newfd` si la duplicacion fue exitosa.
				- `-1`: error.

		- **chdir**: esta funcion cambia el directorio de trabajo actual del proceso. A partir de este momento, todas las rutas relativas se interpretan desde el nuevo directorio, en este proyecto se utiliza antes de ejecutar un CGI para que el programa se ejecute en el directorio correcto.
			- prototipo: `int chdir(const char *path);`
			- parametros:
				- `path`: ruta del directorio al que se quiere cambiar. Puede ser absoluta o relativa.
			- valores de retorno:
				- `0`: el cambio de directorio se realizo correctamente.
				- `-1`: error, el directorio no existe, no hay permisos o la ruta no es valida.

	- ## Utilidades y errores
		- **errno**: variable global que indica el codigo de error de la ultima llamada del sitema que fallo.
			- porsibles valores e enrro con fallos en webserver (estos son algunos ejemplos las fuciones suelen definir que valores de errno usan):
				- `EBADF`: descriptor invalido.
				- `EINTR`: llamada interrumpida por señal.
				- `EINVAL`: argumentos invalidos.
				- `EACCES`: permiso denegado.
				- `EMFILE`: limite de ficheros abiertos por porceso.
				- `ENFILE`: limite global de gicheros abiertos.
			
			- ejemplo de comprobacion con errno en caso de fallo con un fichero
				- **incorrecto**:
					- `if (errno == EBADF) { ... } `.
				- **correcto**:
					- `if (close(fd) == -1 && errno == EBADF) { ... }`.

		- **strerror**: convierte un codigo de error(`errno`) en un mensaje legible para el usuario. (esta funcion solo devuelve el mensaje de `errno` pero no lo modifica)
			- protoripo: `char *strerror(int errnum)`;
			- parametros:
				- `errnum`: codigo de error de la variale de global `errno`.
			- valor de retorno:
				- puntero a string descriptivo del error.
				- no hay que librear la memoria que devuelve..